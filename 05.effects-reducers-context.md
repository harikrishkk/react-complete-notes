# Effects, reducers, context

Main job - user interacts, UI renders & re-renders

- Evaluate , render jsx,
- manage state, props, react to user input.
- when state / prop changes, re-evaluate component

## Side effects

- API requests
- timeouts
- Browser storage

## useEffect hook

```
import { useState, useEffect } from "react";

const User = (props) => {

  const [users, setUsers] = useState([]);
  const [page, setPage] = useState(1);

  const nextPage = () => {
    setPage((prevPage) => prevPage + 1);
  };

  // Side effect -> Action that need to respond based on other actions

  useEffect(() => {

    const id = setInterval(() => console.log("Hello"), 1000);

    fetch(`https://reqres.in/api/users?page=${page}`)
      .then((res) => res.json())
      .then((data) => setUsers([...users, ...data.data]));
    return () => {
      // Wont run until side effect is run once.
      // any cleanup task- runs before next time the useEffect runs
      // and also when component unmounts.
      clearInterval(id);
    };
  }, [page]);

  if (!users) {
    return <h1> Loading..</h1>;
  }

  return (
    <>
      <ul>
        {users.map((user) => {
          return <li key={user.id}>
            {user.first_name}
          </li>;
        })}
      </ul>
      <button onClick={nextPage}>
        Next page
      </button>
    </>
  );
};

export default User;

```

## useReducer

- Helps with state management
- When multiple state needs to be managed together.
- We may use many slices with useState, rather we use the useReducer

```
import { useState, useEffect, useReducer } from "react";

const User = (props) => {
  const INIT_STATE = {
    users: [],
    page: 1,
    perPage: 0,
    loading: false,
    loaded: false,
  };
  const reducer = (state, action) => {
    switch (action.type) {
      case "FETCH_USER_INIT": {
        return {
          ...state,
          loading: true,
        };
      }
      case "FETCH_USER_SUCCESS": {
        return {
          ...state,
          loading: false,
          loaded: true,
          users: action.payload.users,
          page: action.payload.page,
          perPage: action.payload.perPage,
        };
      }

      case "PAGINATE": {
        return {
          ...state,
          page: state.page + 1,
        };
      }
    }

    return state;
  };

  const [state, dispatch] = useReducer(reducer, INIT_STATE);

  const nextPage = () => {
    dispatch({
      type: "PAGINATE",
    });
  };

  useEffect(() => {
    dispatch({
      type: "FETCH_USER_INIT",
    });

    fetch(`https://reqres.in/api/users?page=${state.page}`)
      .then((res) => res.json())
      .then((data) => {
        dispatch({
          type: "FETCH_USER_SUCCESS",
          payload: {
            users: [...state.users, ...data.data],
            page: data.page,
            perPage: data.perPage,
          },
        });
      });
  }, [state.page]);

  const { users } = state;

  if (!users) {
    return <h1> Loading..</h1>;
  }

  return (
    <>
      <ul>
        {users.map((user) => {
          return <li key={user.id}> {user.first_name} </li>;
        })}
      </ul>
      <button onClick={nextPage}> Next page </button>
    </>
  );
};

export default User;

```

Note: When we pass deps, make sure its a property & not an object
Since, the useEffect runs when any of the property within the object changes, which may not be desirable.

## useState vs useReducer

- useState - single independant props
- useReducer - state updates have grouped proeprty that updates together

## React context

If we start forwarding state to nested components, we can consider this alternative.

Inside context/ folder, create auth-context.js

```
import React from "react";

const AuthContext = React.createContext({
  isLoggedIn: false,
  login: () => {},
});

export default AuthContext;

```

and to use the context, in App.js

```
import { useState } from "react";
import AuthContext from "./context/auth-context";

function App() {

  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const onLogin = () => {
    setIsLoggedIn((prevLogin) => !prevLogin);
  };

  const state = {
    isLoggedIn,
    login: onLogin,
  };

  return (
    <AuthContext.Provider value={state}>
      <div className="App">
        <ExpenseItem />
      </div>
    </AuthContext.Provider>
  );
}

```

and in a component anywhere within the wrapped context,
we can use them in 2 ways, one via the useContext hook

```
import { useContext } from "react";
import AuthContext from "../context/auth-context";

const User = (props) => {
  const context = useContext(AuthContext);
  return (
    <div>
      <h1> User is {context.isLoggedIn ? "Logged in" : "Not logged in"}</h1>
      {!context.isLoggedIn && <button onClick={context.login}> Log in </button>}
    </div>
  );
};

export default User;

```

Or, there is an alternative syntax as option 2, via Consumer,
downside being, its verbose, and also, if context is available only within JSX

```
import AuthContext from "../context/auth-context";

const User = (props) => {
  return (
    <AuthContext.Consumer>
      {(context) => {
        return (
          <>
            <h1>
              User is {context.isLoggedIn ? "Logged in" : "Not logged in"}
            </h1>
            {!context.isLoggedIn && (
              <button onClick={context.login}> Log in </button>
            )}
          </>
        );
      }}
    </AuthContext.Consumer>
  );
};

export default User;

```

As a shortcut, for consumers, copy from here.

```
<AuthContext.Consumer>
    {
        (context) => {
        return (

        );
      }
    }
</AuthContext.Consumer>
```

As a part of refactor, auth-context can wrap the whole logic
so that App.js is lean

```
import React from "react";
import { useState } from "react";

const AuthContext = React.createContext({
  isLoggedIn: false,
  login: () => {},
});

export const AuthContextProvider = (props) => {

  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const onLogin = () => {
    setIsLoggedIn((prevLogin) => !prevLogin);
  };

  const state = {
    isLoggedIn,
    login: onLogin,
  };
  return (
    <AuthContext.Provider value={state}>
      {props.children}
    </AuthContext.Provider>
  );
};

export default AuthContext;

```

and in App.js, we just use that component which encapsulates whole logic.

```
import { AuthContextProvider } from "./context/auth-context";

function App() {
  return (
    <AuthContextProvider>
      <div className="App">
        <ExpenseItem />
      </div>
    </AuthContextProvider>
  );
}
```

## Is context a state management replacement?

It can be used for state managment across the whole app. But, limitations being,
context is not optimized for high freqency changes.

eg: Authentication, Localization can be possible candidates for context

It doesnt give access to dev tools.

## Rules for hooks

- Only call hooks within react functions / custom hooks.
- Should not be used within class components
- Call them only at top level, not in block statements or nested functions.
- For useEfect, make sure, we provide deps.

## Forward refs

If we have a method within a component that needs to be called from outside
of it, we can use forwardRef

Create an input component

```
import React, { useRef, useImperativeHandle } from "react";

// This needs to be wrapped in forwardRef, and pass "ref"

const Input = React.forwardRef((props, ref) => {

  const inputRef = useRef();

  const activate = () => {
    inputRef.current.focus();
  };

// This is like an adapter

  useImperativeHandle(ref, () => {
    return {
      focus: activate,
    };
  });
  return (
    <div>
      <label> {props.label} </label>
      <input ref={inputRef} name={props.name} />
    </div>
  );
});

export default Input;

```

we are exposing functionality from a component to its parent to be called
and used from the parent.

And in the parent component

```
import { useContext, useRef } from "react";
import Input from "./Input";

const User = (props) => {

  const usernameRef = useRef();
  const passwordRef = useRef();

  const activate = () => {
    usernameRef.current.focus();
  };
  const activatePswd = () => {
    passwordRef.current.focus();
  };

  return (
    <>
      <div>
        <Input ref={usernameRef}
        label="User Name" name="username" />
        <Input ref={passwordRef}
        label="Password" name="password" />
        <button onClick={activate}>
          focus
        </button>
        <button onClick={activatePswd}>
          focus pswd
        </button>
      </div>
    </>
  );
};

```

In theory, we need to trigger the focus method from outside by calling activate()
For edge cases like focus, scroll etc , we can use this as last resort.
