# State and events

- Declarative approach
- UI is a function of state.

## Adding event listeners.

```
const Person = (props) => {
  const handleClick = () => {
    console.log("clicked");
  };
  return (
    <div>
      <h1> Name {props.name} </h1>
      <button onClick={handleClick}> Change name </button>
    </div>
  );
};

export default Person;
```

We can also use "clickHandler" or events end with "handler"

## Update state

- Component is just a function. So react needs to call the function to update them.
- updater function re-renders the component.
- The updater function is asynchronous.
- State is on a per-component instance for useState.

```
import { useState } from "react";

const Person = () => {
  const [name, setName] = useState("");
  const handleClick = () => {
    setName("Hari");
  };
  return (
    <div>
      <h1> Name {name} </h1>
      <button onClick={handleClick}> Change name </button>
    </div>
  );
};

export default Person;

```

## Inputs

```
import { useState } from "react";

const UserForm = () => {
  const [title, setTitle] = useState("");
  const submitFormHandler = (event) => {
    event.preventDefault();
    console.log(title);
  };
  const inputChangeHandler = (event) => {
    setTitle(event.target.value);
  };
  return (
    <>
      <p> Title: {title} </p>
      <form onSubmit={submitFormHandler}>
        <input type="text"
        onChange={inputChangeHandler} />
        <button type="submit"> Submit </button>
      </form>
    </>
  );
};

export default UserForm;
```

With more than one state slice, we can use an Object. but make sure, we spread the state & overwrite them.

```
import { useState } from "react";

const UserForm = () => {
  const [person, setPerson] = useState({
    name: "",
    age: "",
  });
  const submitFormHandler = (event) => {
    event.preventDefault();
    console.log(person);
  };
  const inputChangeHandler = (event) => {
    setPerson({
      ...person,
      [event.target.name]: event.target.value,
    });
  };
  return (
      <form onSubmit={submitFormHandler}>
        <input name="name"
        type="text"
        onChange={inputChangeHandler} />
        <input name="age"
        type="number"
        onChange={inputChangeHandler} />
        <button type="submit"> Submit </button>
      </form>
  );
};

export default UserForm;
```

## if we need to make sure that state updates properly based on previous state, we need to use function syntax

```
  const inputChangeHandler = (event) => {
    setPerson((prevState) => ({
      ...person,
      [event.target.name]: event.target.value,
    }));
  };
```

Now, state update works on latest state snapshot.

## Resetting state / Two way binding

```
const UserForm = () => {

  <!--- Note, we need to provide an "" initially. Else it throws warning --->

  const [title, setTitle] = useState("");

  const submitFormHandler = (event) => {
    event.preventDefault();
    console.log(title);
    setTitle("");
  };
  const inputChangeHandler = (event) => {
    setTitle(event.target.value);
  };
  return (
    <>
      <form onSubmit={submitFormHandler}>
        <input value={title}
        type="text"
        onChange={inputChangeHandler} />
        <button type="submit"> Submit </button>
      </form>
    </>
  );
};
```

## Parent child communication

From child, we pass an event handler.

```
const UserForm = (props) => {
  const [title, setTitle] = useState("");

  const submitFormHandler = (event) => {
    event.preventDefault();
    setTitle("");
    props.addItemText(title);
  };
```

and in App.js

```
function App() {
  const addItemText = (item) => {
    console.log(item);
  };
  return (
    <div className="App">
      <ExpenseItem addItemText={addItemText} />
    </div>
  );
}
```

Here we **lift the state** up to the parent component.

## Controlled vs uncontrolled

Controlled - A value passed up to the parent components is set back in the child component usually via the "value" attribute along with an onChange handler.

Different terms:

Stateful / Stateless
Container / Presentation / Dumb components.

## Render list & conditional content :

```
{
  persons.map( person => {
    return (
      <div key={person.id}></div>
    )
  })
}
```

Note: We need a key when we loop over items.

To conditionally show / hide

```
{
  person.isAdult && <p> Adult </p>
}
```

```
{
  person.isAdult ? <p> Adult </p> : <p> Minor </p>
}
```

While passing events up, we can do

```
onClick={() => props.handlerMethod(item)}
onClick={props.handlerMethod.bind(null, item )}

```
