## React behind scenes

- Its a JS library for building UI
- ReactDOM is the interface to web and it handles what user sees.
- Whenever props/state/context changes, reacst re-renders to update itself. It lets reactDOM know.
- Reevaluating components doesnt mean rerendering DOM.
- Only the delta between the snapshots are rendered to DOM ( virtual DOM diff )
- If we put a console, we see that the whole component is re-rendered, but only those delta is changed in real DOM
- When parent changes, all of its children too is re-rendered.
- We need to tell, that only if the input prop changes, the component is re-evaluated.

## Prevent unnecessary re-render

- Wrap the child component with React.memo for functional components.

```
export default React.memo(Card)
```

- Optimization comes at a cost. So apply them appropriately.
- Place them at a high level , not on every component.
- If it can cut of entire branches, then its worth.
- The function which was passed down as prop will still change on every re-render as its re-created every time.
- React does a shallow comparison.
- We can prevent function recreation with useCallback().
- A function when passed as a prop, is a callback. What we say is, use the same callback, and do not create a second version of it ( unless some of its dependency changed.)

```
const handleClick = useCallback(() => {

}, [depVariable])
```

- Calling a state update schedules the state update.
- It is not an instant change. React will eventually do it at a later point in time.
- Since multiple state updates can be scheduled together, use the function form to ensure that we act upon the latest snapshot every time.
- If there are multiple synchronous state updates in the same block of code, those are
  batched together.

## useMemo

- If there is logics within code that might be performance intensive, ie, sorting a list which has 10,000 items, we already have useCallback which can store function objects & rebuild them only when their inputs changed.

For other kinds of data, we have something similar. - useMemo

We can memoize result of expensive calculations.

```
const sortedList = useMemo(() => {
  return items.sort((a, b) => a - b);
}, [items]);
```

We use this far less often than useCallback. We memoize data far less often.
